from cStringIO import StringIO
import numpy as np
import scipy.ndimage as nd
import PIL.Image
import PIL.ImageFilter
from scipy.ndimage.filters import gaussian_filter
from google import protobuf as pb
import sys
import math
import os
import pickle
import caffe


class ImageGenerator():
        """
        Object constructor: intitializes all of the relevent parameters for the network as well as the model and network itself.
        trained_file represents the trained model file that is being used to generate images
        model_file is the protocol buffer that specifies the model
        src_layer represents the input layer of the image
        output_layer represents thae output layer of the network
        prob_layer represents the probability layer that tells you p(c|x)
        learning_rate is adjusted to make the images change faster
        jitter represents the random shake between iterations of image generation
        gaussian_blur is a blur effect that is used in between iterations of the network to prevent overfitting
        """
        def __init__(self, trained_file, model_file,src_layer,output_layer,prob_layer,learning_rate=1.5,jitter=0,gaussian_blur=False):
            self.trained_file=trained_file
            self.model_file=model_file
            self.learning_rate=learning_rate
            self.jitter=jitter
            self.gaussian_blur=gaussian_blur
            self.src_layer=src_layer
            self.output_layer=output_layer
            self.prob_layer=prob_layer
            model = caffe.io.caffe_pb2.NetParameter()
            
            pb.text_format.Merge(open(self.model_file).read(), model)
            model.force_backward = True
            open('tmp.prototxt','w').write(str(model))
            caffe.set_mode_gpu()
            self.net = caffe.Classifier('tmp.prototxt', self.trained_file,
                                             mean = np.float32([104.0, 116.0, 122.0]), # ImageNet mean, training set dependent
                                             channel_swap = (2,1,0)) # the reference model has channels in BGR order instead of RGB

        """
        preprocess: formats the image so it can be used
        net the network variable that must be passed here
        img a floating point representation of the image that will be adjusted
        """
        def preprocess(self,net, img):
            return np.float32(np.rollaxis(img, 2)[::-1]) - net.transformer.mean['data']

        """
        deprocess: reverses the formatting affect of preprocess
        net the network variable that must be passed here
        img a floating point representation of the image that will be adjusted
        """
        def deprocess(self,net, img):
            return np.dstack((img + net.transformer.mean['data'])[::-1])

        """
        generate_number_image: generates an image by iterating over a certain number of times
        width represetns the width of the image
        height represents the height of the image
        num_iters represents the number of times alter_image is called
        class_num represents the index for the class that is to be generated by the network
        output_file represents the path of the file that is being outputed
        input_img is the start image that will be altered ; if None is specified then a noise image will be used
        """
        def generate_number_image(self,width,height,num_iters, class_num, output_file, input_img=None):
            self.net = caffe.Classifier('tmp.prototxt', self.trained_file,
                                            mean = np.float32([104.0, 116.0, 122.0]), # ImageNet mean, training set dependent
                                            channel_swap = (2,1,0)) # the reference model has channels in BGR order instead of RGB
            net=self.net
            net.blobs[self.src_layer].data[:] = self.process_image(width,height)
            
            for i in range(num_iters):
                self.alter_image(class_num)
                self.save_net_as_image(output_file,width,height)

        """
        generate_probable_image: generates an image by iterating until the probability of it being a class is over a certain threshold
        width represetns the width of the image
        height represents the height of the image
        threshold represents the probability threshold for the image
        class_num represents the index for the class that is to be generated by the network
        output_file represents the path of the file that is being outputed
        input_img is the start image that will be altered ; if None is specified then a noise image will be used
        """
        def generate_probable_image(self,width,height,threshold, class_num, output_file, input_img=None):
            probability=0.0
         
            self.net = caffe.Classifier('tmp.prototxt', self.trained_file,
                                     mean = np.float32([104.0, 116.0, 122.0]), # ImageNet mean, training set dependent
                                     channel_swap = (2,1,0)) # the reference model has channels in BGR order instead of RGB
            net=self.net
            net.blobs[self.src_layer].data[:] = self.process_image(width,height)
            #None for input means random
            while(probability<threshold):
                probability=self.alter_image(class_num)
                self.save_net_as_image(output_file,width,height)

        """   
        alter_image: a single iteration of the image alteration
        class_num the class that the image is being oriented towards
        """
        def alter_image(self,class_num):
            net=self.net
            src = net.blobs[self.src_layer]       
            #JITTER SHIFT/REGULARIZER
            ox, oy = np.random.randint(-self.jitter, self.jitter+1, 2)
            src.data[0] = np.roll(np.roll(src.data[0], ox, -1), oy, -2) # apply jitter shift
            #GRADIENTS
            prob = net.forward()
            calc_prob=prob[self.prob_layer][0][class_num]
            net.blobs[self.output_layer].diff[0][class_num] = 1  #954 banana, 100 black swan
            net.backward(start=self.output_layer)
         
            g = src.diff[0]
            src.data[:] += self.learning_rate/np.abs(g).mean() * g #"IMAGE UPDATE"
 
            #UNSHIFT 
            src.data[0] = np.roll(np.roll(src.data[0], -ox, -1), -oy, -2)

            #CLIP
            bias = net.transformer.mean[self.src_layer]
            src.data[:] = np.clip(src.data, -bias, 255-bias)
        
            return calc_prob

        """
        generate_random: generates a random numpy float array of size width x height representing the input of the network
        width the width of the array
        height the height of the random array
        """
        def generate_random(self,width,height):
            return np.random.random((width,height,3))*(width+1)
    
        """
        image_probability: retuns the probability that an image at path is of a class
        path represents the path of the image
        class_num represents the class that is being oriented towardes
        """
        def image_probability(self,path,class_num):
            img = np.float32(PIL.Image.open(path))
            img = [self.preprocess(self.net, img)]
            self.net.blobs['data'].data[:] = img
            loss= self.net.forward()
            return loss['prob'][0][class_num]
    
        """
        process_image: gives an array form of an image, if the input image is None then a random image is used 
        width represents the width of the image
        height represents the height of the image
        input_img represents the path of the input image to be altered
        """
        def process_image(self,width,height,input_img=None):
            if input_img==None:
                img = self.generate_random(width,height)
                img = [self.preprocess(self.net,img)]
            else:
                img = np.float32(PIL.Image.open(input_image))
                img = [self.preprocess(self.net, img)]
            return img

        """
        save_net_as_image: saves the network as an image
        output_file is a file path for the image to be saved
        width is the width of the image
        height is the height of the image
        """
        def save_net_as_image(self,output_file,width,height):
            img = self.net.blobs[self.src_layer].data[:]
            img = img.reshape(3,width,height)
            img = self.deprocess(self.net, img)
            out_img=np.uint8(np.clip(img,0,255))
            PIL.Image.fromarray(out_img).save(output_file)

